// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using Microsoft.CodeAnalysis.Text;
using Roslyn.Utilities;

namespace Microsoft.CodeAnalysis
{
    /// <summary>
    /// Describes a command line metadata reference (assembly or netmodule) specification.
    /// </summary>
    public struct CommandLineReference
    {
        private readonly string reference;
        private readonly MetadataReferenceProperties properties;
        private readonly bool isAssemblyName;

        internal CommandLineReference(string reference, MetadataReferenceProperties properties, bool isAssemblyName)
        {
            Debug.Assert(!string.IsNullOrEmpty(reference));
            this.reference = reference;
            this.properties = properties;
            this.isAssemblyName = isAssemblyName;
        }

        /// <summary>
        /// Metadata file path or an assembly display name.
        /// </summary>
        public string Reference
        {
            get { return reference; }
        }

        /// <summary>
        /// Metadata reference properties.
        /// </summary>
        public MetadataReferenceProperties Properties
        {
            get
            {
                return properties;
            }
        }

        /// <summary>
        /// True if <see cref="Reference"/> is an assembly name, false if it is a path.
        /// </summary>
        public bool IsAssemblyName
        {
            get
            {
                return isAssemblyName;
            }
        }

        /// <summary>
        /// Resolves this command line metadata reference to a <see cref="MetadataReference"/> using given file resolver and metadata provider.
        /// </summary>
        /// <exception cref="BadImageFormatException">If the PE image format is invalid and <paramref name="diagnosticsOpt"/> is null.</exception>
        /// <exception cref="FileNotFoundException">If the Metadata file could not be found and <paramref name="diagnosticsOpt"/> is null.</exception>
        /// <exception cref="IOException">If error reading the file from disk and <paramref name="diagnosticsOpt"/> is null.</exception>
        /// <remarks>
        /// NOTE: Other exceptions, apart from those mentioned above, may be generated by the fileResolver or the metadata provider. These are not handled by this method.
        /// </remarks>
        /// <param name="fileResolver">The file resolver to use for assembly name and relative path resolution.</param>
        /// <param name="metadataProvider">Uses to create metadata references from resolved full paths.</param>
        /// <param name="diagnosticsOpt">Optional diagnostics list for storing diagnostics.</param>
        /// <param name="messageProviderOpt">Optional <see cref="CommonMessageProvider"/> for generating diagnostics.</param>
        /// <returns>Returns resolved metadata reference or <see cref="UnresolvedMetadataReference"/>.</returns>
        internal MetadataReference Resolve(FileResolver fileResolver, MetadataReferenceProvider metadataProvider, List<DiagnosticInfo> diagnosticsOpt, CommonMessageProvider messageProviderOpt)
        {
            Debug.Assert(fileResolver != null);
            Debug.Assert(metadataProvider != null);

            string path;
            if (this.IsAssemblyName)
            {
                path = fileResolver.ResolveAssemblyName(this.reference);
                if (path == null)
                {
                    if (diagnosticsOpt != null)
                    {
                        diagnosticsOpt.Add(new DiagnosticInfo(messageProviderOpt, messageProviderOpt.ERR_MetadataFileNotFound, this.reference));
                    }

                    return new UnresolvedMetadataReference(this.reference, this.properties);
                }
            }
            else
            {
                path = this.reference;
            }

            // use search paths and base path of the resolver - usually these are the same as the paths stored on the arguments:
            string fullPath = fileResolver.ResolveMetadataFileChecked(path, baseFilePath: null);
            if (fullPath == null)
            {
                if (diagnosticsOpt != null)
                {
                    diagnosticsOpt.Add(new DiagnosticInfo(messageProviderOpt, messageProviderOpt.ERR_MetadataFileNotFound, this.reference));
                }

                return new UnresolvedMetadataReference(this.reference, this.properties);
            }
            else
            {
                return ResolveMetadataFile(fullPath, this.properties, metadataProvider, this.reference, diagnosticsOpt, messageProviderOpt);
            }
        }

        /// <summary>
        /// Resolves a command line metadata reference with the given <paramref name="resolvedFullPath"/> to a <see cref="MetadataReference"/>.
        /// </summary>
        private static MetadataReference ResolveMetadataFile(
            string resolvedFullPath,
            MetadataReferenceProperties properties,
            MetadataReferenceProvider metadataProvider,
            string display,
            List<DiagnosticInfo> diagnosticsOpt,
            CommonMessageProvider messageProviderOpt)
        {
            Debug.Assert(resolvedFullPath != null);
            Debug.Assert(PathUtilities.IsAbsolute(resolvedFullPath));
            Debug.Assert(display != null);

            if (diagnosticsOpt == null)
            {
                return metadataProvider.GetReference(resolvedFullPath, properties);
            }

            MetadataReference reference;
            Diagnostic diagnostic;
            if (PortableExecutableReference.TryGetMetadata(
                    properties.Kind == MetadataImageKind.Assembly,
                    messageProviderOpt,
                    Location.None,
                    display,
                    () => metadataProvider.GetReference(resolvedFullPath, properties),
                    out reference,
                    out diagnostic))
            {
                return reference;
            }

            diagnosticsOpt.Add(((DiagnosticWithInfo)diagnostic).Info);
            return new UnresolvedMetadataReference(resolvedFullPath, properties);
        }
    }
}
